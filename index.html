<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>1inch LP Scanner</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" type="application/javascript"></script>

    <style>
      :root { --gap: 12px; }
      * { box-sizing: border-box; }
      body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 16px; }
      pre { background:#fafafa; padding:12px; border:1px solid #eee; border-radius:8px; }
      .row { display:flex; flex-wrap:wrap; gap: var(--gap); align-items:center; margin: 0 0 var(--gap) 0; }
      .btn { padding: 8px 12px; border:1px solid #ddd; border-radius:8px; background:#fff; cursor:pointer; }
      .btn[disabled] { opacity:.5; cursor:not-allowed; }
      label { font-size: 12px; color:#555; display:block; margin-bottom:4px; }
      input[type=text]{ padding:8px; border-radius:8px; border:1px solid #ddd; min-width: 280px; }
      table { width:100%; border-collapse:collapse; }
      th, td { padding:8px; border-bottom:1px solid #eee; text-align:left; }
      th { background:#fafafa; position:sticky; top:0; }
      #container { min-height: 60vh; }

      /* Modal */
      .modal { display:none; position: fixed; inset:0; background: rgba(0,0,0,.4); z-index: 100; }
      .modal[open] { display:block; }
      .modal-content { background:#fff; margin: 10vh auto; padding:20px; border-radius: 12px; border:1px solid #eee; width:min(640px, 92vw); text-align:center; }
      .wallet-modal { display:grid; gap:8px; }
      .wallet-option { display:flex; gap:8px; align-items:center; justify-content:flex-start; padding:8px; border:1px solid #eee; border-radius:8px; cursor:pointer; }
      .wallet-option:hover { background:#fafafa; }
      .wallet-icon { width: 24px; height:24px; object-fit:contain; }
    </style>
  </head>

  <body>
    <pre>
This helps you withdraw liquidity from the 1inch Liquidity Protocol.
Connect a wallet and the app will list all LP token balances across ETH (v1 & v1.1), BNB, and Mooniswap.
Click "Withdraw" to call the pool's withdraw(amount, [0,0]) or "Exit" for farming contracts.
    </pre>

    <div class="row">
      <button id="connectWallet" class="btn">Connect wallet</button>
      <button id="checkAcct" class="btn" disabled>Check For Liquidity</button>
      <button id="stopScan" class="btn" disabled>Stop Scan</button>
    </div>

    <div class="row">
      <div>
        <label for="ethRPC">Ethereum RPC (v1.1)</label>
        <input type="text" id="ethRPC" value="https://eth.drpc.org" />
      </div>
      <div>
        <label for="ethRPCv1">Ethereum RPC (v1.0)</label>
        <input type="text" id="ethRPCv1" value="https://eth.drpc.org" />
      </div>
      <div>
        <label for="bnbRPC">BNB Chain RPC</label>
        <input type="text" id="bnbRPC" value="https://bsc-dataseed.binance.org/" />
      </div>
    </div>

    <div id="container">
      <table id="table" aria-live="polite">
        <thead>
          <tr>
            <th>Pool / Farm</th>
            <th>Balance (raw)</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <!-- Loading Modal -->
    <div id="loadingModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="loadingTitle">
      <div class="modal-content">
        <p id="loadingTitle">Please wait, scanning poolsâ€¦</p>
        <p id="loadingSub"></p>
        <button id="cancelLoading" class="btn">Cancel</button>
      </div>
    </div>

    <!-- Wallet picker Modal (programmatically filled) -->
    <div id="walletModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="walletTitle">
      <div class="modal-content">
        <h3 id="walletTitle" style="margin-top:0">Select a Wallet</h3>
        <div id="walletList" class="wallet-modal"></div>
        <button id="closeWalletModal" class="btn" style="margin-top:8px;">Close</button>
      </div>
    </div>

    <script type="module">
      // ===== Constants =====
      const ADDR = {
        multicall: "0xcA11bde05977b3631167028862bE2a173976CA11",
        factories: {
          ETH_v11: "0xbAF9A5d4b0052359326A6CDAb54BABAa3a3A9643",
          ETH_v10: "0xC4A8B7e29E3C8ec560cd4945c1cF3461a85a148d",
          BNB:     "0xD41B24bbA51fAc0E4827b6F94C0D6DDeB183cD64",
          MOONISWAP_FACTORY: "0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303",
        },
      };

      // ABIs kept minimal but functionally identical
      const FACTORY_ABI = [{ inputs:[], name:"getAllPools", outputs:[{ internalType:"address[]", name:"", type:"address[]" }], stateMutability:"view", type:"function" }];
      const MULTICALL3_ABI = [{
        inputs:[{components:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"callData",type:"bytes"}],internalType:"struct Multicall3.Call[]",name:"calls",type:"tuple[]"}],
        name:"aggregate", outputs:[{internalType:"uint256",name:"blockNumber",type:"uint256"},{internalType:"bytes[]",name:"returnData",type:"bytes[]"}], stateMutability:"payable", type:"function"
      }];
      const WITHDRAW_ABI = ["function withdraw(uint256,uint256[])"]; // pool withdraw
      const FARMING_ABI = [
        { inputs:[], name:"exit", outputs:[], stateMutability:"nonpayable", type:"function" },
        { inputs:[{ internalType:"address", name:"account", type:"address" }], name:"balanceOf", outputs:[{ internalType:"uint256", name:"", type:"uint256" }], stateMutability:"view", type:"function" }
      ];

      // Static farming lists (unchanged)
      const BNB_FARMS = [
        "0x5D0EC1F843c1233D304B96DbDE0CAB9Ec04D71EF",
        "0x7731f8df999a9441ae10519617c24568dc82f697",
        "0xcb06df7f0be5b8bb261d294cf87c794eb9da85b1",
        "0x8b01d28f4fddd89322711d832325f7eb1f122fb2",
      ];
      const FARMS = [
        "0x13927A60c7bf4d3d00E3C1593E0Ec713E35d2106","0xd7936052d1e096d48c81ef3918f9fd6384108480","0x302a6eda4e2b2c563a80cc17bd80a1251b986677","0x2ec255797fef7669fa243509b7a599121148ffba","0x94bc2a1c732bcad7343b25af48385fe76e08734f","0xa218543cc21ee9388fa1e509f950fd127ca82155","0xd7012cdebf10d5b352c601563aa3a8d1795a3f52","0x98484d4259a70b73af58180521f2eb71a3f00ae6","0xa83fcea9229c7f1e02acb46abe8d6889259339e8","0x0da1b305d7101359434d71eceaab71e1ff5437e6","0x4dab1ba9609c1546a0a69a76f00ed935b0b9c45e","0x9070832cf729a5150bb26825c2927e7d343eabd9","0xe22f6a5dd9e491dfab49faefdb32d01aaf99703e","0xca6e3ebf4ac8c3e84bccdf5cd89aece74d69f2a7","0xc7c42eccac0d4bb790a32bc86519ac362e01d388","0x2ede375d73d81dbd19ef58a75ba359dd28d25de8","0x8acdb3bcc5101b1ba8a5070f003a77a2da376fe8","0x18d410f651289bb978fc32f90d2d7e608f4f4560","0x7cb203834ce6792756541d722d94296f4c1ca356","0xc84dcdaff87f9b5639db82f434c8ba1c2023f6eb","0xeb7dbc5a64d2d083d774595e560b147c5021eacd","0xa355b4b904ce09bd1847f4cf133769bc0dfbc51b","0x8ba0ef03c26fa2a11bde30db4e87c87408b9761b","0x7ded1b278d244f707214759c45c1540834890e95","0x8b1af1298f5c0ca8a6b4e66626a4bdae0f7521e5","0x48371588e964f1e8939127af68622e32268640fa","0x950a9414700e8ee8041c1cab5a0c6afddf0e9257","0x2cb9e71a5cf989008ba93dad8edb988ec1b4182f","0x598032ba8e7acb625ea6854b4696e25afa2ec9f0","0x73f5e5260423a2742d9f8ac49dea6cb5eaec465e","0x1055f60bbf27d233c4e34d2e03e35567427415fa","0xe65184b402376703adc27a7d7e0e8d35a264a240","0xd7012cdebf10d5b352c601563aa3a8d1795a3f52",
      ];

      const CHAIN_HEX = { 1: "0x1", 56: "0x38" };
      const ZERO_32 = "0x" + "0".repeat(64);
      const BAL_OF_SIG = "0x70a08231"; // ERC20 balanceOf(address)

      // Scan configs are now declarative
      const SCAN_GROUPS = [
        { label: "ETH v1.1", chain: 1,  rpcInput: "ethRPC",   factoryKey: "ETH_v11" },
        { label: "BNB",      chain: 56, rpcInput: "bnbRPC",   factoryKey: "BNB" },
        { label: "ETH v1.0", chain: 1,  rpcInput: "ethRPCv1", factoryKey: "ETH_v10" },
        { label: "Mooniswap",chain: 1,  rpcInput: "ethRPC",   factoryKey: "MOONISWAP_FACTORY" },
      ];

      const providers6963 = []; // EIP-6963 providers
      let eip6963Index = -1;    // which wallet was chosen
      let web3Provider;         // ethers.providers.Web3Provider
      let signer;               // ethers.Signer
      let userAddress;          // string
      let stopScan = false;

      const $ = sel => document.querySelector(sel);
      const byId = id => document.getElementById(id);
      const nonZero = hex => hex && hex !== ZERO_32;
      const toCall = (target, calldata) => ({ target, allowFailure: true, callData: calldata });
      const balanceOfCalldataFor = addr => BAL_OF_SIG + "0".repeat(24) + addr.slice(2);
      const openModal = el => el.setAttribute("open", "");
      const closeModal = el => el.removeAttribute("open");
      const chunk = (arr, size) => Array.from({length: Math.ceil(arr.length/size)}, (_,i)=>arr.slice(i*size,(i+1)*size));
      const updateLoading = msg => (byId("loadingSub").textContent = msg ?? "");

      function createRow(addr, rawBal, onClick, label = "Withdraw") {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${addr}</td><td>${String(BigInt(rawBal))}</td><td><button class="btn">${label}</button></td>`;
        tr.querySelector("button").addEventListener("click", onClick);
        return tr;
      }

      // ===== Wallet handling (EIP-6963 with graceful fallback) =====
      window.addEventListener("eip6963:announceProvider", (e) => { providers6963.push(e.detail); });
      window.dispatchEvent(new Event("eip6963:requestProvider"));

      function getSelectedProvider(){
        const base = (eip6963Index >= 0 && providers6963[eip6963Index]) ? providers6963[eip6963Index].provider : (window.ethereum ?? null);
        if(!base) throw new Error("No wallet provider found");
        web3Provider = new ethers.providers.Web3Provider(base);
        signer = web3Provider.getSigner();
        return web3Provider;
      }

      async function promptWallet(){
        const list = byId("walletList");
        list.innerHTML = "";
        if(providers6963.length === 0 && !window.ethereum){
          list.innerHTML = `<p>No EIP-6963 providers detected. If you have a browser wallet installed, refresh and try again.</p>`;
        }
        providers6963.forEach((p, i) => {
          const item = document.createElement("div");
          item.className = "wallet-option";
          item.innerHTML = `<img src="${p.info.icon}" class="wallet-icon" alt=""><span>${p.info.name}</span>`;
          item.addEventListener("click", async () => {
            eip6963Index = i;
            const provider = getSelectedProvider();
            const accounts = await provider.send("eth_requestAccounts", []);
            userAddress = ethers.utils.getAddress(accounts[0]);
            byId("connectWallet").textContent = "Disconnect";
            byId("checkAcct").disabled = false;
            closeModal(byId("walletModal"));
          });
          list.appendChild(item);
        });
        if(window.ethereum){
          const item = document.createElement("div");
          item.className = "wallet-option";
          item.textContent = "Use injected wallet (window.ethereum)";
          item.addEventListener("click", async () => {
            eip6963Index = -1;
            const provider = getSelectedProvider();
            const accounts = await provider.send("eth_requestAccounts", []);
            userAddress = ethers.utils.getAddress(accounts[0]);
            byId("connectWallet").textContent = "Disconnect";
            byId("checkAcct").disabled = false;
            closeModal(byId("walletModal"));
          });
          list.appendChild(item);
        }
        openModal(byId("walletModal"));
      }

      async function ensureChain(hexId){
        if(!web3Provider) throw new Error("No provider");
        try { await web3Provider.send("wallet_switchEthereumChain", [{ chainId: hexId }]); }
        catch (e) { console.error("switch chain", e); throw e; }
      }

      // ===== Actions =====
      async function withdrawLiquidity(poolAddr, amountHex, chainNum){
        await ensureChain(CHAIN_HEX[chainNum]);
        const contract = new ethers.Contract(poolAddr, WITHDRAW_ABI, signer);
        await contract.withdraw(amountHex, [0, 0]);
      }
      async function exitFarming(farmAddr, _amountHexIgnored, chainNum){
        await ensureChain(CHAIN_HEX[chainNum]);
        const contract = new ethers.Contract(farmAddr, FARMING_ABI, signer);
        await contract.exit();
      }

      // ===== Scanning =====
      function providerFromInput(inputId){
        return new ethers.providers.JsonRpcProvider(byId(inputId).value);
      }

      async function fetchPoolsForGroup(group){
        const provider = providerFromInput(group.rpcInput);
        const factory = new ethers.Contract(ADDR.factories[group.factoryKey], FACTORY_ABI, provider);
        const pools = await factory.getAllPools();
        const multicall = new ethers.Contract(ADDR.multicall, MULTICALL3_ABI, provider);
        return { ...group, provider, multicall, pools };
      }

      async function scanPoolsAndRender(){
        stopScan = false;
        byId("tbody").innerHTML = "";
        openModal(byId("loadingModal"));
        byId("stopScan").disabled = false;

        const groups = await Promise.all(SCAN_GROUPS.map(fetchPoolsForGroup));
        const BATCH = 100;

        for(const g of groups){
          const chunks = chunk(g.pools, BATCH);
          for(let i=0;i<chunks.length;i++){
            if(stopScan) break;
            updateLoading(`${g.label}: ${i*BATCH} â€“ ${Math.min(g.pools.length, (i+1)*BATCH)} of ${g.pools.length}`);
            const calls = chunks[i].map(p => toCall(p, balanceOfCalldataFor(userAddress)));
            let returns;
            try {
              const result = await g.multicall.callStatic.aggregate(calls);
              // ethers.js throws for revert, but if a provider returns a JSON error, it may be in result.error
              if (result && result.error) {
                updateLoading('An error occured, this is likely your RPC, we reccomend a freemium RPC for checking');
                continue;
              }
              [, returns] = result;
            } catch (e) {
              updateLoading('An error occured, this is likely your RPC, we reccomend a freemium RPC for checking');
              continue;
            }
            returns.forEach((ret, idx) => {
              if(nonZero(ret)){
                const addr = calls[idx].target;
                byId("tbody").appendChild(
                  createRow(addr, ret, () => withdrawLiquidity(addr, ret, g.chain), "Withdraw")
                );
              }
            });
          }
        }

        closeModal(byId("loadingModal"));
        byId("stopScan").disabled = true;
      }

      async function checkFarmingBalances(account){
        const farmIface = new ethers.utils.Interface(FARMING_ABI);
        const multicallAddr = ADDR.multicall;
        const multicallAbi = MULTICALL3_ABI;

        async function multicallBalanceOf(farms, provider, chain) {
          if (!farms.length) return;
          const multicall = new ethers.Contract(multicallAddr, multicallAbi, provider);
          const calls = farms.map(farm => toCall(farm, farmIface.encodeFunctionData("balanceOf", [account])));
          const [, results] = await multicall.callStatic.aggregate(calls);
          results.forEach((ret, idx) => {
            if(nonZero(ret)){
              const addr = farms[idx];
              byId("tbody").appendChild(
                createRow(addr, ret, () => exitFarming(addr, ret, chain), "Exit")
              );
            }
          });
        }

        await Promise.all([
          multicallBalanceOf(FARMS, providerFromInput('ethRPCv1'), 1),
          multicallBalanceOf(BNB_FARMS, providerFromInput('bnbRPC'), 56),
        ]);
      }

      // ===== Events =====
      byId("connectWallet").addEventListener("click", async (e) => {
        e.preventDefault();
        const btn = byId("connectWallet");
        if(btn.textContent === "Disconnect"){
          eip6963Index = -1; web3Provider = undefined; signer = undefined; userAddress = undefined;
          btn.textContent = "Connect wallet";
          byId("checkAcct").disabled = true;
          return;
        }
        await promptWallet();
      });

      byId("checkAcct").addEventListener("click", async (e) => {
        e.preventDefault();
        if(!signer){ getSelectedProvider(); }
        if(!userAddress){
          const accs = await web3Provider.send("eth_requestAccounts", []);
          userAddress = ethers.utils.getAddress(accs[0]);
        }
        await Promise.all([
          scanPoolsAndRender(),
          checkFarmingBalances(userAddress),
        ]);
      });

      const stop = () => { stopScan = true; byId("stopScan").disabled = true; closeModal(byId("loadingModal")); };
      byId("stopScan").addEventListener("click", stop);
      byId("cancelLoading").addEventListener("click", stop);
      byId("closeWalletModal").addEventListener("click", () => closeModal(byId("walletModal")));

      // Accessibility: close modals on Escape
      window.addEventListener("keydown", (e) => {
        if(e.key === "Escape") { closeModal(byId("walletModal")); closeModal(byId("loadingModal")); }
      });
    </script>
  </body>
</html>
